# Contributing

## Requirements

- The Xcode version [mentioned in the README](./README.md#requirements)
- [Mint](https://github.com/yonaskolb/Mint) package manager
- Node.js (any recent version should be fine)

## Setup

1. `mint bootstrap` — this will take quite a long time (~5 minutes on my machine) the first time you run it
2. `npm install`

## Running the tests

Either:

- `swift test`, or
- open `AblyChat.xcworkspace` in Xcode and test the `AblyChat` scheme

## Linting

To check formatting and code quality, run `swift run BuildTool lint`. Run with `--fix` to first automatically fix things where possible.

## Development guidelines

- The aim of the [example app](README.md#example-app) is that it demonstrate all of the core functionality of the SDK. So if you add a new feature, try to add something to the example app to demonstrate this feature.
- We should aim to make it easy for consumers of the SDK to be able to mock out the SDK in the tests for their own code. A couple of things that will aid with this:
  - Describe the SDK’s functionality via protocols (when doing so would still be sufficiently idiomatic to Swift).
  - When defining a `struct` that is emitted by the public API of the library, make sure to define a public memberwise initializer so that users can create one to be emitted by their mocks. (There is no way to make Swift’s autogenerated memberwise initializer public, so you will need to write one yourself. In Xcode, you can do this by clicking at the start of the type declaration and doing Editor → Refactor → Generate Memberwise Initializer.)
- When writing code that implements behaviour specified by the Chat SDK features spec, add a comment that references the identifier of the relevant spec item.

### Testing guidelines

#### Attributing tests to a spec point

When writing a test that relates to a spec point from the Chat SDK features spec, add a comment that contains one of the following tags:

- `@spec <spec-item-id>` — The test case directly tests all the functionality documented in the spec item.
- `@specOneOf(m/n) <spec-item-id>` — The test case is the m<sup>th</sup> of n test cases which, together, test all of the functionality documented in the spec item.
- `@specPartial <spec-item-id>` — The test case tests some, but not all, of the functionality documented in the spec item. This is different to `@specOneOf` in that it implies that the test suite does not fully test this spec item.

`<spec-item-id>` should be a spec item identifier such as `CHA-RL3g`.

Each of the above tags can optionally be followed by a hyphen and a comment which explains how the test relates to the given spec item.

Examples:

```swift
// @spec CHA-EX3f
func test1 { … }
```

```swift
// @specOneOf(1/2) CHA-EX2h — Tests the case where the room is FAILED
func test2 { … }

// @specOneOf(2/2) CHA-EX2h — Tests the case where the room is SUSPENDED
func test3 { … }
```

```swift
// @specIncomplete CHA-EX1h4 - Tests that we retry, but not the retry attempt limit because we’ve not implemented it yet
func test4 { … }
```

In [#46](https://github.com/ably-labs/ably-chat-swift/issues/46), we’ll write a script that uses these tags to generate a report about how much of the feature spec we’ve implemented.

## Building for Swift 6

At the time of writing (August 2024), the latest version of Swift to ship with a release version of Xcode is Swift 5.10. However, in the next few months Apple will launch Swift 6, which refines the strict concurrency checking introduced in Swift 5.10. Specifically, my understanding is that it introduces features that make Swift 5.10’s strict concurrency checking more developer-friendly. I think that some of these features can be switched on in Swift 5.10, but I’m not sure if all of them can. So, Swift 6 releases we might decide that we want to switch to using Swift 6 for our SDK. So, in CI, in addition to Swift 5 language mode, we also try building the SDK in Swift 6 language mode using the latest Xcode 16 beta.

And, actually more importantly, we want to be sure that the SDK can be integrated into a user’s application that uses Swift 6. So, in CI, in addition to Swift 5 language mode, we also try building the example app in Swift 6 language mode using the aforementioned Xcode beta.

(If any of the above turns out to cause a lot of problems due to the quality of the beta software, we can reconsider this.)

### Multiple `Package.swift` files

We have a separate manifest file, `Package@swift-6.swift`, which a Swift compiler supporting Swift 6 will use instead of `Package.swift` (see [documentation of this SPM feature](https://github.com/swiftlang/swift-package-manager/blob/74f06f8a7fd6b4c729e474dee34db66319d90759/Documentation/Usage.md#version-specific-manifest-selection)). This file exists for two reasons:

1. To tell the compiler “use the Swift 6 language mode to compile this package if the compiler supports Swift 6, else use the Swift 5 language mode” (I previously tried passing `-Xswiftc -swift-version -Xswiftc 6` to `swift build` but this seems to then use Swift 6 language mode for compiling not just our own package, but all of our dependencies, which is likely to fail.)
2. If you try to use `.enableUpcomingFeature` for a feature that is enabled by default in Swift 6, you’ll get an error `error: upcoming feature 'BareSlashRegexLiterals' is already enabled as of Swift version 6`. (I don’t know if there’s a better way of handling this.)

So, we need to make sure we keep `Package.swift` and `Package@swift-6.swift` in sync manually.
